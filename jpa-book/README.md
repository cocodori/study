# 자바 ORM 표준 JPA 프로그래밍

## 1. 데이터 중심 설계의 문제점

테이블 외래키를 객체에 그대로 가져온 부분, 이를 테 OrderItem클래스의 orderId나, itemId 같은 부분은 문제가 될 수 있다.
왜냐하면 관계형 데이터베이스는 연관된 객체를 찾을 때 외래키를 이용해서 조인하면 되지만, 객체에는 조인이라는 기능이 없다. 객체는
연관된 객체를 찾을 때 **참조**를 사용한다. 

 지금처럼 객체를 참조하지 않고, 외래키를 그대로 가지고 있으면 order.getMember()처럼 객체 그래프 탐색을 할 수 없다.
 이렇게 외래키만 가지고 있으면 연관된 엔티티를 찾을 때 외래 키로 데이터베이스에 다시 조회해야 한다.
 
 ```java
Order order = em.find(Order.class, orderId);

//외래 키로 다시 조회
Member member = em.find(Member.class, order.getMemberId();
``` 

참조를 이용하면 더 간편하게 조회할 수 있다.

```java
Order oder = em.find(Order.class , orderId);
//참조를 사용하므로 다시 DB에 조회할 필요가 없다.
Member member = order.getMember(); 
```
객체는 참조를 사용해서 연관된 객체를 찾고, 데이터베이스는 외래 키를 사용해서 연관된 테이블을 찾는다.
JPA는 객체의 참조와 테이블의 외래킬를 매핑해서 객체에서는 참조를, 테이블에서는 외래 키를 사용할 수 있도록 지원한다.

## 2. 데이터베이스의 연관관계와 객체의 연관관계

데이터베이스는 FK 하나만으로 양방향 참조가 가능하다. 하지만 객체에는 FK가 없다. 양방향도 없다. 양방향을 참조하려면 양쪽에서 서로를 참조하는, 
서로 다른 방향을 가진 두 개의 참조가 필요하다.

@ManyToOne과 @OneToMany로 양방향 관계를 맺어줄 수 있다. PK를 가진 엔티티(@OneToMany) 쪽에서 FK를 가진 엔티티를 조회할 일이 없다면
양방향 참조를 사용할 때까지 뒤로 밀어도 좋다. JPA는 양방향 연관관계를 사용할 때 주인이 아닌 엔티티는 @MappedBy를 이용해 반드시 연관관계의 주인을 명시해야 한다.
mappdBy는 주인이 아닌 엔티티에만 존재해야 한다.
누가 연관관계의 주인일까? FK를 가진 엔티티가 연관관계의 주인이다. 즉 @ManyToOne을 가진 엔티티가 연관관계의 주인이 된다.

## 3. 다양한 연관관계 매핑

- 주문과 배송(OneToOne)
    
    주문(Order)과 배송(Delivery)는 일대일 관계다. 객체 관계를 고려할 때 주문에서 배송으로 자주 접근할 예정이므로 외래 키를 주문 테이블이 가진다.
    
    참고로 일대일 관계이므로 ORDER테이블에 있는 DELIVERY_ID 외래 키에는 유니크 제약 조건을 주는 것이 좋다.
    
    Order가 매핑된 ORDER를 주 테이블로 보고 외래 키를 Order에 두었다. 따라서 외래 키가 있는 Order.delivery가 연관관계의 주인이다.
    Delivery.order 필드에는 mappedBy 속성을 사용해서 주인이 아님을 표시했다.
    

- 상품과 카테고리(ManyToMany)
    
    한 상품은 여러 카테고리에 속할 수 있고, 한 카테고리도 여러 상품을 가질 수 있으므로 둘은 다대다 관계다. 테이블로는 이런 다대다 관계를 표현할 수 없다.
    CATEGORY_ITEM이라는 연결 테이블을 추가해서 다대다 관계를 일대다, 다대일 관계로 풀어내야 한다.

    Category와 Item은 다대다 관계고 그 반대도 다대다 관계다. Category.items필드를 보면 @ManyToMany와 @JoinTable을 사용해서
    CATEGORY_ITEM 연결 테이블을 바로 매핑했다. 여기서 Category를 연관관계 주인으로 정했다. 따라서 주인이 아닌 Item.categories필드에 mappedBy 속성을 사용해서 주인이 아님을 표시했다.
    
    다대다 관계는 연결 테이블을 JPA가 알아서 처리해주므로 편리하지만, 연결 테이블에 필드가 추가되면 더 이상 사용할 수 없다.
    실무에서 활용하기는 무리가 있다. 따라서 CategoryItem이라는 연결 엔티티를 사용하는 것을 권장한다.
    
## 4. 상속 관계 매핑

 다른 상속 관계는 잘 사용되지 않는다. 예제에서는 편의를 위해 권장되지 않는 방법인 단일 테이블 전략으로 상속을 구현했다. 날짜를 입력 받는 부분은 ```@MappedSuperclass```로 구현했다.

## 5. 연관관계 관리
글로벌 페치 전략은 개발 시에는 모두 lazy를 사용하고 애플리케이션 배포 시점에 반드시 같이 로딩 되어야 하는 것을 선별해서 EAGER로딩으로 바꾸는 것이 좋다.

영속성 전이를 이용하면 특정 엔티티를 영속 상태로 만들 때, 관련된 엔티티들까지 함께 영속 상태로 만들 수 있다.
